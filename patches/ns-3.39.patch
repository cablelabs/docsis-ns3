diff -Naur ns-3.39/src/applications/CMakeLists.txt docsis31_ns3_model/src/applications/CMakeLists.txt
--- ns-3.39/src/applications/CMakeLists.txt	2023-08-31 20:41:59.291179371 -0700
+++ docsis31_ns3_model/src/applications/CMakeLists.txt	2023-08-31 18:10:55.092384164 -0700
@@ -2,6 +2,7 @@
   LIBNAME applications
   SOURCE_FILES
     helper/bulk-send-helper.cc
+    helper/file-transfer-helper.cc
     helper/on-off-helper.cc
     helper/packet-sink-helper.cc
     helper/three-gpp-http-helper.cc
@@ -9,6 +10,8 @@
     helper/udp-echo-helper.cc
     model/application-packet-probe.cc
     model/bulk-send-application.cc
+    model/file-transfer-application.cc
+    model/game-client.cc
     model/onoff-application.cc
     model/packet-loss-counter.cc
     model/packet-sink.cc
@@ -26,6 +29,7 @@
     model/udp-trace-client.cc
   HEADER_FILES
     helper/bulk-send-helper.h
+    helper/file-transfer-helper.h
     helper/on-off-helper.h
     helper/packet-sink-helper.h
     helper/three-gpp-http-helper.h
@@ -33,6 +37,8 @@
     helper/udp-echo-helper.h
     model/application-packet-probe.h
     model/bulk-send-application.h
+    model/file-transfer-application.h
+    model/game-client.h
     model/onoff-application.h
     model/packet-loss-counter.h
     model/packet-sink.h
diff -Naur ns-3.39/src/applications/helper/file-transfer-helper.cc docsis31_ns3_model/src/applications/helper/file-transfer-helper.cc
--- ns-3.39/src/applications/helper/file-transfer-helper.cc	1969-12-31 16:00:00.000000000 -0800
+++ docsis31_ns3_model/src/applications/helper/file-transfer-helper.cc	2023-08-31 18:10:55.092384164 -0700
@@ -0,0 +1,80 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2008 INRIA
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Geoge Riley <riley@ece.gatech.edu>
+ * Adapted from OnOffHelper by:
+ * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ */
+
+#include "file-transfer-helper.h"
+
+#include "ns3/inet-socket-address.h"
+#include "ns3/names.h"
+#include "ns3/packet-socket-address.h"
+#include "ns3/string.h"
+
+namespace ns3
+{
+
+FileTransferHelper::FileTransferHelper(std::string protocol, Address address)
+{
+    m_factory.SetTypeId("ns3::FileTransferApplication");
+    m_factory.Set("Protocol", StringValue(protocol));
+    m_factory.Set("Remote", AddressValue(address));
+}
+
+void
+FileTransferHelper::SetAttribute(std::string name, const AttributeValue& value)
+{
+    m_factory.Set(name, value);
+}
+
+ApplicationContainer
+FileTransferHelper::Install(Ptr<Node> node) const
+{
+    return ApplicationContainer(InstallPriv(node));
+}
+
+ApplicationContainer
+FileTransferHelper::Install(std::string nodeName) const
+{
+    Ptr<Node> node = Names::Find<Node>(nodeName);
+    return ApplicationContainer(InstallPriv(node));
+}
+
+ApplicationContainer
+FileTransferHelper::Install(NodeContainer c) const
+{
+    ApplicationContainer apps;
+    for (NodeContainer::Iterator i = c.Begin(); i != c.End(); ++i)
+    {
+        apps.Add(InstallPriv(*i));
+    }
+
+    return apps;
+}
+
+Ptr<Application>
+FileTransferHelper::InstallPriv(Ptr<Node> node) const
+{
+    Ptr<Application> app = m_factory.Create<Application>();
+    node->AddApplication(app);
+
+    return app;
+}
+
+} // namespace ns3
diff -Naur ns-3.39/src/applications/helper/file-transfer-helper.h docsis31_ns3_model/src/applications/helper/file-transfer-helper.h
--- ns-3.39/src/applications/helper/file-transfer-helper.h	1969-12-31 16:00:00.000000000 -0800
+++ docsis31_ns3_model/src/applications/helper/file-transfer-helper.h	2023-08-31 18:10:55.092384164 -0700
@@ -0,0 +1,111 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2008 INRIA
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Geoge Riley <riley@ece.gatech.edu>
+ * Adapted from OnOffHelper by:
+ * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ */
+
+#ifndef FILE_TRANSFER_HELPER_H
+#define FILE_TRANSFER_HELPER_H
+
+#include "ns3/address.h"
+#include "ns3/application-container.h"
+#include "ns3/attribute.h"
+#include "ns3/net-device.h"
+#include "ns3/node-container.h"
+#include "ns3/object-factory.h"
+
+#include <stdint.h>
+#include <string>
+
+namespace ns3
+{
+
+/**
+ * \ingroup filetransfer
+ * \brief A helper to make it easier to instantiate an ns3::FileTransferApplication
+ * on a set of nodes.
+ */
+class FileTransferHelper
+{
+  public:
+    /**
+     * Create an FileTransferHelper to make it easier to work with FileTransferApplications
+     *
+     * \param protocol the name of the protocol to use to send traffic
+     *        by the applications. This string identifies the socket
+     *        factory type used to create sockets for the applications.
+     *        A typical value would be ns3::UdpSocketFactory.
+     * \param address the address of the remote node to send traffic
+     *        to.
+     */
+    FileTransferHelper(std::string protocol, Address address);
+
+    /**
+     * Helper function used to set the underlying application attributes,
+     * _not_ the socket attributes.
+     *
+     * \param name the name of the application attribute to set
+     * \param value the value of the application attribute to set
+     */
+    void SetAttribute(std::string name, const AttributeValue& value);
+
+    /**
+     * Install an ns3::FileTransferApplication on each node of the input container
+     * configured with all the attributes set with SetAttribute.
+     *
+     * \param c NodeContainer of the set of nodes on which an FileTransferApplication
+     * will be installed.
+     * \returns Container of Ptr to the applications installed.
+     */
+    ApplicationContainer Install(NodeContainer c) const;
+
+    /**
+     * Install an ns3::FileTransferApplication on the node configured with all the
+     * attributes set with SetAttribute.
+     *
+     * \param node The node on which an FileTransferApplication will be installed.
+     * \returns Container of Ptr to the applications installed.
+     */
+    ApplicationContainer Install(Ptr<Node> node) const;
+
+    /**
+     * Install an ns3::FileTransferApplication on the node configured with all the
+     * attributes set with SetAttribute.
+     *
+     * \param nodeName The node on which an FileTransferApplication will be installed.
+     * \returns Container of Ptr to the applications installed.
+     */
+    ApplicationContainer Install(std::string nodeName) const;
+
+  private:
+    /**
+     * Install an ns3::FileTransferApplication on the node configured with all the
+     * attributes set with SetAttribute.
+     *
+     * \param node The node on which an FileTransferApplication will be installed.
+     * \returns Ptr to the application installed.
+     */
+    Ptr<Application> InstallPriv(Ptr<Node> node) const;
+
+    ObjectFactory m_factory; //!< Object factory.
+};
+
+} // namespace ns3
+
+#endif /* FILE_TRANSFER_HELPER_H */
diff -Naur ns-3.39/src/applications/model/bulk-send-application.cc docsis31_ns3_model/src/applications/model/bulk-send-application.cc
--- ns-3.39/src/applications/model/bulk-send-application.cc	2023-08-31 20:41:59.291179371 -0700
+++ docsis31_ns3_model/src/applications/model/bulk-send-application.cc	2023-08-31 20:38:27.001508404 -0700
@@ -88,12 +88,17 @@
             .AddTraceSource("TxWithSeqTsSize",
                             "A new packet is created with SeqTsSizeHeader",
                             MakeTraceSourceAccessor(&BulkSendApplication::m_txTraceWithSeqTsSize),
-                            "ns3::PacketSink::SeqTsSizeCallback");
+                            "ns3::PacketSink::SeqTsSizeCallback")
+            .AddTraceSource("ConnectionCompleted",
+                            "Report statistics on successfully completed connection",
+                            MakeTraceSourceAccessor(&BulkSendApplication::m_traceCompleted),
+                            "ns3::BulkSendApplication::ConnectionCompletedTracedCallback");
     return tid;
 }
 
 BulkSendApplication::BulkSendApplication()
     : m_socket(nullptr),
+      m_closed(true),
       m_connected(false),
       m_totBytes(0),
       m_unsentPacket(nullptr)
@@ -107,6 +112,47 @@
 }
 
 void
+BulkSendApplication::NormalClose(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+    NS_ASSERT_MSG(socket == m_socket, "Received callback for other socket");
+    NS_LOG_DEBUG("Connection completed for "
+                 << m_totBytes << " in " << (Simulator::Now() - m_connectionStartTime).As(Time::S));
+    m_traceCompleted(m_totBytes, Simulator::Now() - m_connectionStartTime);
+    m_closed = true;
+}
+
+void
+BulkSendApplication::Restart()
+{
+    NS_LOG_FUNCTION(this);
+    if (m_closed)
+    {
+        if (m_socket)
+        {
+            m_socket = nullptr;
+        }
+    }
+    else
+    {
+        StopApplication();
+        m_closed = true;
+        m_socket = nullptr;
+    }
+    m_totBytes = 0;
+    m_connected = false;
+    StartApplication();
+}
+
+void
+BulkSendApplication::ErrorClose(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+    NS_ASSERT_MSG(socket == m_socket, "Received callback for other socket");
+    NS_LOG_WARN("Error close received");
+}
+
+void
 BulkSendApplication::SetMaxBytes(uint64_t maxBytes)
 {
     NS_LOG_FUNCTION(this << maxBytes);
@@ -184,6 +230,8 @@
         m_socket->SetConnectCallback(MakeCallback(&BulkSendApplication::ConnectionSucceeded, this),
                                      MakeCallback(&BulkSendApplication::ConnectionFailed, this));
         m_socket->SetSendCallback(MakeCallback(&BulkSendApplication::DataSend, this));
+        m_socket->SetCloseCallbacks(MakeCallback(&BulkSendApplication::NormalClose, this),
+                                    MakeCallback(&BulkSendApplication::ErrorClose, this));
     }
     if (m_connected)
     {
@@ -301,6 +349,7 @@
     NS_LOG_FUNCTION(this << socket);
     NS_LOG_LOGIC("BulkSendApplication Connection succeeded");
     m_connected = true;
+    m_connectionStartTime = Simulator::Now();
     Address from;
     Address to;
     socket->GetSockName(from);
diff -Naur ns-3.39/src/applications/model/bulk-send-application.h docsis31_ns3_model/src/applications/model/bulk-send-application.h
--- ns-3.39/src/applications/model/bulk-send-application.h	2023-08-31 20:41:59.295179404 -0700
+++ docsis31_ns3_model/src/applications/model/bulk-send-application.h	2023-08-31 20:38:19.817452837 -0700
@@ -105,6 +105,16 @@
      * \return pointer to associated socket
      */
     Ptr<Socket> GetSocket() const;
+    /**
+     * \brief Reset the state of the application to its initialized state,
+     *        and start another transfer.
+     */
+    void Restart();
+
+    /**
+     * \brief Documentation string ConnectionCompleted for traced callback
+     */
+    typedef void (*ConnectionCompletedTracedCallback)(uint64_t bytes, Time duration);
 
   protected:
     void DoDispose() override;
@@ -124,6 +134,7 @@
     Ptr<Socket> m_socket;                //!< Associated socket
     Address m_peer;                      //!< Peer address
     Address m_local;                     //!< Local address to bind to
+    bool m_closed;                       //!< True if closed
     bool m_connected;                    //!< True if connected
     uint32_t m_sendSize;                 //!< Size of data to send each time
     uint64_t m_maxBytes;                 //!< Limit total number of bytes sent
@@ -132,6 +143,7 @@
     uint32_t m_seq{0};                   //!< Sequence
     Ptr<Packet> m_unsentPacket;          //!< Variable to cache unsent packet
     bool m_enableSeqTsSizeHeader{false}; //!< Enable or disable the SeqTsSizeHeader
+    Time m_connectionStartTime;          //!< Start time of connection
 
     /// Traced Callback: sent packets
     TracedCallback<Ptr<const Packet>> m_txTrace;
@@ -141,6 +153,9 @@
     TracedCallback<Ptr<const Packet>, const Address&, const Address&, const SeqTsSizeHeader&>
         m_txTraceWithSeqTsSize;
 
+    /// Callback for tracing completion
+    TracedCallback<uint64_t, Time> m_traceCompleted;
+
   private:
     /**
      * \brief Connection Succeeded (called by Socket through a callback)
@@ -160,7 +175,10 @@
      * \param socket socket to use
      * \param unused actually unused
      */
-    void DataSend(Ptr<Socket> socket, uint32_t unused);
+    void DataSend(Ptr<Socket> socket, uint32_t unused); // for socket's SetSendCallback
+
+    void NormalClose(Ptr<Socket> socket);
+    void ErrorClose(Ptr<Socket> socket);
 };
 
 } // namespace ns3
diff -Naur ns-3.39/src/applications/model/file-transfer-application.cc docsis31_ns3_model/src/applications/model/file-transfer-application.cc
--- ns-3.39/src/applications/model/file-transfer-application.cc	1969-12-31 16:00:00.000000000 -0800
+++ docsis31_ns3_model/src/applications/model/file-transfer-application.cc	2023-08-31 20:36:30.400616350 -0700
@@ -0,0 +1,445 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2010 Georgia Institute of Technology
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: George F. Riley <riley@ece.gatech.edu>
+ */
+
+#include "file-transfer-application.h"
+
+#include "ns3/address.h"
+#include "ns3/boolean.h"
+#include "ns3/event-id.h"
+#include "ns3/log.h"
+#include "ns3/node.h"
+#include "ns3/nstime.h"
+#include "ns3/packet.h"
+#include "ns3/pointer.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/simulator.h"
+#include "ns3/socket-factory.h"
+#include "ns3/socket.h"
+#include "ns3/string.h"
+#include "ns3/tcp-socket-factory.h"
+#include "ns3/tcp-socket.h"
+#include "ns3/trace-source-accessor.h"
+#include "ns3/udp-socket-factory.h"
+#include "ns3/uinteger.h"
+
+namespace ns3
+{
+
+NS_LOG_COMPONENT_DEFINE("FileTransferApplication");
+
+NS_OBJECT_ENSURE_REGISTERED(FileTransferApplication);
+
+TypeId
+FileTransferApplication::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::FileTransferApplication")
+            .SetParent<Application>()
+            .SetGroupName("Applications")
+            .AddConstructor<FileTransferApplication>()
+            .AddAttribute("SendSize",
+                          "The number of bytes to write per socket send",
+                          UintegerValue(512),
+                          MakeUintegerAccessor(&FileTransferApplication::m_sendSize),
+                          MakeUintegerChecker<uint32_t>(1))
+            .AddAttribute("Remote",
+                          "The address of the destination",
+                          AddressValue(),
+                          MakeAddressAccessor(&FileTransferApplication::m_peer),
+                          MakeAddressChecker())
+            .AddAttribute("SndBufSize",
+                          "TCP transmit buffer size (bytes);"
+                          "if non-zero, overrides TcpSocket default",
+                          UintegerValue(0),
+                          MakeUintegerAccessor(&FileTransferApplication::m_tcpSndBufSize),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute("RcfBufSize",
+                          "TCP receive buffer size (bytes);"
+                          "if non-zero, overrides TcpSocket default",
+                          UintegerValue(0),
+                          MakeUintegerAccessor(&FileTransferApplication::m_tcpRcvBufSize),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute("FileSize",
+                          "The total number of bytes to send. The value zero means "
+                          "that there is no limit.",
+                          UintegerValue(0),
+                          MakeUintegerAccessor(&FileTransferApplication::m_fileSize),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute("UseRandomFileSize",
+                          "Flag for whether file size should be drawn from random distribution",
+                          BooleanValue(false),
+                          MakeBooleanAccessor(&FileTransferApplication::m_useRandomFileSize),
+                          MakeBooleanChecker())
+            .AddAttribute("RandomFileSize",
+                          "A random variable that governs file size (bytes)",
+                          StringValue("ns3::ConstantRandomVariable[Constant=1]"),
+                          MakePointerAccessor(&FileTransferApplication::m_randomFileSize),
+                          MakePointerChecker<RandomVariableStream>())
+            .AddAttribute("Protocol",
+                          "The type of protocol to use.",
+                          TypeIdValue(TcpSocketFactory::GetTypeId()),
+                          MakeTypeIdAccessor(&FileTransferApplication::m_tid),
+                          MakeTypeIdChecker())
+            .AddAttribute("UseReadingTime",
+                          "Flag for whether reading time (FTP Model 2) is used",
+                          BooleanValue(false),
+                          MakeBooleanAccessor(&FileTransferApplication::m_useReadingTime),
+                          MakeBooleanChecker())
+            .AddAttribute("ReadingTime",
+                          "A random variable that governs reading time",
+                          StringValue("ns3::ConstantRandomVariable[Constant=5]"),
+                          MakePointerAccessor(&FileTransferApplication::m_readingTime),
+                          MakePointerChecker<RandomVariableStream>())
+            .AddAttribute("UseRestartInterval",
+                          "Flag for whether repeating transfers (similar to FTP model 1) is used",
+                          BooleanValue(false),
+                          MakeBooleanAccessor(&FileTransferApplication::m_useRestartInterval),
+                          MakeBooleanChecker())
+            .AddAttribute("RestartInterval",
+                          "A random variable that governs restart time",
+                          StringValue("ns3::ConstantRandomVariable[Constant=5]"),
+                          MakePointerAccessor(&FileTransferApplication::m_restartInterval),
+                          MakePointerChecker<RandomVariableStream>())
+            .AddAttribute("UseFileTransferDuration",
+                          "Flag for whether file transfers are truncated",
+                          BooleanValue(false),
+                          MakeBooleanAccessor(&FileTransferApplication::m_useFileTransferDuration),
+                          MakeBooleanChecker())
+            .AddAttribute("FileTransferDuration",
+                          "Time after which to terminate a transfer and close the socket if not "
+                          "yet completed",
+                          TimeValue(Seconds(2.5)),
+                          MakeTimeAccessor(&FileTransferApplication::m_fileTransferDuration),
+                          MakeTimeChecker())
+            .AddTraceSource("Tx",
+                            "A new packet is created and is sent",
+                            MakeTraceSourceAccessor(&FileTransferApplication::m_txTrace),
+                            "ns3::Packet::TracedCallback")
+            .AddTraceSource("Connected",
+                            "Set to true upon socket connection, false upon close",
+                            MakeTraceSourceAccessor(&FileTransferApplication::m_connected),
+                            "ns3::TracedValueCallback::Bool")
+            .AddTraceSource("FileTransferCompletion",
+                            "Report on the socket event CloseSucceeded",
+                            MakeTraceSourceAccessor(&FileTransferApplication::m_report),
+                            "ns3::FileTransferApplication::FileTransferCompletionCallback");
+    return tid;
+}
+
+FileTransferApplication::FileTransferApplication()
+    : m_socket(nullptr),
+      m_tcpSndBufSize(0),
+      m_tcpRcvBufSize(0),
+      m_connected(false),
+      m_totBytes(0),
+      m_sendFileEvent(EventId())
+{
+    NS_LOG_FUNCTION(this);
+}
+
+FileTransferApplication::~FileTransferApplication()
+{
+    NS_LOG_FUNCTION(this);
+}
+
+void
+FileTransferApplication::SetFileSize(uint32_t fileSize)
+{
+    NS_LOG_FUNCTION(this << fileSize);
+    m_fileSize = fileSize;
+}
+
+uint32_t
+FileTransferApplication::GetTotalBytes() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_totBytes;
+}
+
+Ptr<Socket>
+FileTransferApplication::GetSocket() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_socket;
+}
+
+int64_t
+FileTransferApplication::AssignStreams(int64_t stream)
+{
+    NS_LOG_FUNCTION(this << stream);
+    m_readingTime->SetStream(stream + 1);
+    m_randomFileSize->SetStream(stream + 2);
+    return 2;
+}
+
+void
+FileTransferApplication::DoDispose()
+{
+    NS_LOG_FUNCTION(this);
+
+    m_socket = nullptr;
+    // chain up
+    Application::DoDispose();
+}
+
+bool
+FileTransferApplication::SendFile()
+{
+    NS_LOG_FUNCTION(this);
+    if (m_socket)
+    {
+        NS_LOG_FUNCTION("Socket exists; ignoring request");
+        return false;
+    }
+    m_totBytes = 0;
+    m_socket = Socket::CreateSocket(GetNode(), m_tid);
+    Ptr<TcpSocket> tcpSocket = m_socket->GetObject<TcpSocket>();
+    if (tcpSocket && m_tcpSndBufSize > 0)
+    {
+        NS_LOG_DEBUG("Setting TCP send buffer size to " << m_tcpSndBufSize);
+        tcpSocket->SetAttribute("SndBufSize", UintegerValue(m_tcpSndBufSize));
+    }
+    if (tcpSocket && m_tcpRcvBufSize > 0)
+    {
+        NS_LOG_DEBUG("Setting TCP receive buffer size to " << m_tcpRcvBufSize);
+        tcpSocket->SetAttribute("RcvBufSize", UintegerValue(m_tcpRcvBufSize));
+    }
+    if (Inet6SocketAddress::IsMatchingType(m_peer))
+    {
+        m_socket->Bind6();
+    }
+    else if (InetSocketAddress::IsMatchingType(m_peer))
+    {
+        m_socket->Bind();
+    }
+
+    m_socket->Connect(m_peer);
+    m_socket->ShutdownRecv();
+    m_socket->SetConnectCallback(MakeCallback(&FileTransferApplication::ConnectionSucceeded, this),
+                                 MakeCallback(&FileTransferApplication::ConnectionFailed, this));
+    m_socket->SetSendCallback(MakeCallback(&FileTransferApplication::DataSend, this));
+    m_socket->SetCloseCallbacks(MakeCallback(&FileTransferApplication::CloseSucceeded, this),
+                                MakeCallback(&FileTransferApplication::CloseFailed, this));
+    NS_LOG_LOGIC("FileTransferApplication: Starting file transfer of size "
+                 << m_fileSize << " at time " << Simulator::Now().GetSeconds());
+    m_fileStartTime = Simulator::Now();
+    if (m_connected || m_tid == UdpSocketFactory::GetTypeId())
+    {
+        SendData();
+    }
+    return true;
+}
+
+// Application Methods
+void
+FileTransferApplication::StartApplication() // Called at time specified by Start
+{
+    NS_LOG_FUNCTION(this);
+    NS_ABORT_MSG_IF(m_useReadingTime && m_useRestartInterval, "Flags cannot both be set");
+    SendFile();
+}
+
+void
+FileTransferApplication::StopApplication() // Called at time specified by Stop
+{
+    NS_LOG_FUNCTION(this);
+
+    if (m_socket)
+    {
+        m_socket->Close();
+        m_connected = false;
+    }
+    else
+    {
+        NS_LOG_WARN("FileTransferApplication found null socket to close in StopApplication");
+    }
+    if (m_sendFileEvent.IsRunning())
+    {
+        Simulator::Cancel(m_sendFileEvent);
+    }
+    if (m_scheduledFileTransferEnd.IsRunning())
+    {
+        Simulator::Cancel(m_scheduledFileTransferEnd);
+    }
+}
+
+// Private helpers
+
+void
+FileTransferApplication::SendData()
+{
+    NS_LOG_FUNCTION(this);
+
+    while (m_fileSize == 0 || m_totBytes < m_fileSize)
+    { // Time to send more
+        uint32_t toSend = m_sendSize;
+        // Make sure we don't send too many
+        if (m_fileSize > 0)
+        {
+            toSend = std::min(m_sendSize, m_fileSize - m_totBytes);
+        }
+        NS_LOG_LOGIC("sending packet at " << Simulator::Now());
+        Ptr<Packet> packet = Create<Packet>(toSend);
+        m_txTrace(packet);
+        int actual = m_socket->Send(packet);
+        if (actual > 0)
+        {
+            m_totBytes += actual;
+        }
+        // We exit this loop when actual < toSend as the send side
+        // buffer is full. The "DataSent" callback will pop when
+        // some buffer space has freed ip.
+        if ((unsigned)actual != toSend)
+        {
+            break;
+        }
+    }
+    // Check if time to close (all sent)
+    if (m_totBytes == m_fileSize && (m_connected || m_tid == UdpSocketFactory::GetTypeId()))
+    {
+        NS_LOG_LOGIC("FileTransferApplication closing");
+        m_socket->Close();
+        m_connected = false;
+    }
+    if (m_tid == UdpSocketFactory::GetTypeId())
+    {
+        m_socket = nullptr;
+    }
+}
+
+void
+FileTransferApplication::ConnectionSucceeded(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+    NS_LOG_LOGIC("FileTransferApplication Connection succeeded");
+    m_connected = true;
+    if (m_useFileTransferDuration && m_tid != UdpSocketFactory::GetTypeId())
+    {
+        Time duration = m_fileTransferDuration - (Simulator::Now() - m_fileStartTime);
+        if (duration < Seconds(0))
+        {
+            NS_LOG_WARN("The connection setup time "
+                        << (Simulator::Now() - m_fileStartTime).GetSeconds()
+                        << " exceeded the max file duration time "
+                        << m_fileTransferDuration.GetSeconds());
+            // Handle this as if the connection succeeded by closing.  This will
+            // not be logged as an actual file transfer, but a new file transfer
+            // can subsequently be started (i.e. do not error exit from this).
+            HandleScheduledFileTransferEnd();
+            return;
+        }
+        else
+        {
+            m_scheduledFileTransferEnd =
+                Simulator::Schedule(duration,
+                                    &FileTransferApplication::HandleScheduledFileTransferEnd,
+                                    this);
+        }
+    }
+    if (m_useRandomFileSize)
+    {
+        m_fileSize = m_randomFileSize->GetInteger();
+        NS_LOG_LOGIC("Drawing file size " << m_fileSize << " from distribution");
+    }
+    SendData();
+}
+
+void
+FileTransferApplication::ConnectionFailed(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+    NS_LOG_LOGIC("FileTransferApplication Connection failed");
+    m_socket->Close();
+}
+
+void
+FileTransferApplication::CloseSucceeded(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+    NS_LOG_LOGIC("FileTransferApplication Close succeeded");
+    m_socket = nullptr;
+    if (m_scheduledFileTransferEnd.IsRunning())
+    {
+        Simulator::Cancel(m_scheduledFileTransferEnd);
+    }
+    m_report(Simulator::Now() - m_fileStartTime,
+             m_totBytes,
+             m_totBytes * 8 / (Simulator::Now() - m_fileStartTime).GetSeconds());
+    NS_LOG_DEBUG("CloseSucceeded duration: "
+                 << (Simulator::Now() - m_fileStartTime).GetSeconds() << " bytes: " << m_totBytes
+                 << " rate (bps) "
+                 << m_totBytes * 8 / (Simulator::Now() - m_fileStartTime).GetSeconds());
+    if (m_useReadingTime)
+    {
+        double nextTimeValue = m_readingTime->GetValue();
+        NS_ABORT_MSG_UNLESS(nextTimeValue > 0, "Illegal next time");
+        NS_LOG_LOGIC("Scheduling another file transfer in " << nextTimeValue << " seconds");
+        m_sendFileEvent =
+            Simulator::Schedule(Seconds(nextTimeValue), &FileTransferApplication::SendFile, this);
+    }
+    else if (m_useRestartInterval)
+    {
+        Time nextTime = m_fileStartTime + Seconds(m_restartInterval->GetValue());
+        if (Simulator::Now() > nextTime)
+        {
+            nextTime = Simulator::Now();
+        }
+        NS_LOG_LOGIC("Scheduling another file transfer in "
+                     << (nextTime - Simulator::Now()).GetSeconds() << " seconds");
+        m_sendFileEvent = Simulator::Schedule((nextTime - Simulator::Now()),
+                                              &FileTransferApplication::SendFile,
+                                              this);
+    }
+}
+
+void
+FileTransferApplication::CloseFailed(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+    NS_LOG_LOGIC("FileTransferApplication Close failed");
+    m_socket = nullptr;
+    if (m_scheduledFileTransferEnd.IsRunning())
+    {
+        Simulator::Cancel(m_scheduledFileTransferEnd);
+    }
+}
+
+void
+FileTransferApplication::DataSend(Ptr<Socket>, uint32_t)
+{
+    NS_LOG_FUNCTION(this);
+
+    if (m_connected || m_tid == UdpSocketFactory::GetTypeId())
+    { // Only send new data if the connection has completed
+        NS_LOG_LOGIC("FileTransferApplication DataSent callback triggers new SendData() call");
+        Simulator::ScheduleNow(&FileTransferApplication::SendData, this);
+    }
+}
+
+void
+FileTransferApplication::HandleScheduledFileTransferEnd()
+{
+    NS_LOG_FUNCTION(this);
+    NS_LOG_LOGIC("FileTransferApplication closing based on scheduled end");
+    m_socket->Close();
+    m_connected = false;
+}
+
+} // Namespace ns3
diff -Naur ns-3.39/src/applications/model/file-transfer-application.h docsis31_ns3_model/src/applications/model/file-transfer-application.h
--- ns-3.39/src/applications/model/file-transfer-application.h	1969-12-31 16:00:00.000000000 -0800
+++ docsis31_ns3_model/src/applications/model/file-transfer-application.h	2023-08-31 20:36:18.076523386 -0700
@@ -0,0 +1,209 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2010 Georgia Institute of Technology
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: George F. Riley <riley@ece.gatech.edu>
+ */
+
+#ifndef FILE_TRANSFER_APPLICATION_H
+#define FILE_TRANSFER_APPLICATION_H
+
+#include "ns3/address.h"
+#include "ns3/application.h"
+#include "ns3/event-id.h"
+#include "ns3/ptr.h"
+#include "ns3/traced-callback.h"
+#include "ns3/traced-value.h"
+
+namespace ns3
+{
+
+class Address;
+class Socket;
+class RandomVariableStream;
+
+/**
+ * \ingroup applications
+ * \defgroup filetransfer FileTransferApplication
+ *
+ * This traffic generator simply sends data
+ * as fast as possible up to FileSize or until
+ * the application is stopped (if FileSize is
+ * zero). Once the lower layer send buffer is
+ * filled, it waits until space is free to
+ * send more data, essentially keeping a
+ * constant flow of data. Only SOCK_STREAM
+ * and SOCK_SEQPACKET sockets are supported.
+ * For example, TCP sockets can be used, but
+ * UDP sockets can not be used.
+ */
+
+/**
+ * \ingroup filetransfer
+ *
+ * \brief Send as much traffic as possible, trying to fill the bandwidth.
+ *
+ * This traffic generator simply sends data
+ * as fast as possible up to FileSize or until
+ * the application is stopped (if FileSize is
+ * zero). Once the lower layer send buffer is
+ * filled, it waits until space is free to
+ * send more data, essentially keeping a
+ * constant flow of data. Only SOCK_STREAM
+ * and SOCK_SEQPACKET sockets are supported.
+ * For example, TCP sockets can be used, but
+ * UDP sockets can not be used.
+ *
+ */
+class FileTransferApplication : public Application
+{
+  public:
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    FileTransferApplication();
+
+    ~FileTransferApplication() override;
+
+    /**
+     * \brief Set the file size to try to transfer
+     *
+     * \param fileSize the size of a file to try to transfer
+     */
+    void SetFileSize(uint32_t fileSize);
+
+    /**
+     * \brief Get the total number of bytes that have been sent during this
+     *        object's lifetime.
+     *
+     * return the total number of bytes that have been sent
+     */
+    uint32_t GetTotalBytes() const;
+
+    /**
+     * \brief Send another file
+     *
+     * return true if another file was started; false if the request
+     *        didn't succeed (possibly because another transfer is ongoing)
+     */
+    bool SendFile();
+
+    /**
+     * \brief Get the socket this application is attached to.
+     * \return pointer to associated socket
+     */
+    Ptr<Socket> GetSocket() const;
+
+    /**
+     * \brief Assign a fixed random variable stream number to the random variables
+     * used by this model.
+     *
+     * \param stream first stream index to use
+     * \return the number of stream indices assigned by this model
+     */
+    int64_t AssignStreams(int64_t stream);
+
+    /**
+     * TracedCallback signature for file transfer completion report
+     *
+     * \param [in] completionTime completion time for the transfer
+     * \param [in] bytes number of bytes transferred
+     * \param [in] throughput throughput in bits/sec
+     */
+    typedef void (*FileTransferCompletionCallback)(Time completionTime,
+                                                   uint32_t bytes,
+                                                   double throughput);
+
+  protected:
+    void DoDispose() override;
+
+  private:
+    // inherited from Application base class.
+    void StartApplication() override; // Called at time specified by Start
+    void StopApplication() override;  // Called at time specified by Stop
+
+    /**
+     * \brief Send data until the L4 transmission buffer is full.
+     */
+    void SendData();
+
+    Ptr<Socket> m_socket;                        //!< Associated socket
+    Address m_peer;                              //!< Peer address
+    uint32_t m_tcpSndBufSize;                    //!< TCP send buffer size (if non-zero)
+    uint32_t m_tcpRcvBufSize;                    //!< TCP receive buffer size (if non-zero)
+    TracedValue<bool> m_connected;               //!< True if connected
+    uint32_t m_sendSize;                         //!< Size of data to send each time
+    uint32_t m_fileSize;                         //!< Limit total number of bytes sent
+    uint32_t m_totBytes;                         //!< Total bytes sent so far
+    TypeId m_tid;                                //!< The type of protocol to use.
+    bool m_useRandomFileSize;                    //!< Whether to use random file size
+    Ptr<RandomVariableStream> m_randomFileSize;  //!< rng for file size
+    bool m_useReadingTime;                       //!< Whether to start again after reading time
+    Ptr<RandomVariableStream> m_readingTime;     //!< rng for reading time
+    bool m_useRestartInterval;                   //!< Whether to restart transfer periodically
+    Ptr<RandomVariableStream> m_restartInterval; //!< rng for restartInterval
+    bool m_useFileTransferDuration;              //!< Whether to use file transfer duration
+    Time m_fileTransferDuration; //!< Time after which to terminate a transfer and close the socket
+                                 //!< if not yet completed
+    EventId m_sendFileEvent;     //!< Event id of pending SendFile()
+    EventId m_scheduledFileTransferEnd; //!< Event id of pending Close
+
+    Time m_fileStartTime; //!< Start time of current file transfer
+
+    /// Traced Callback: sent packets
+    TracedCallback<Ptr<const Packet>> m_txTrace;
+
+    /// Traced Callback: report on successful connection close
+    TracedCallback<Time, uint32_t, double> m_report;
+
+  private:
+    /**
+     * \brief Connection Succeeded (called by Socket through a callback)
+     * \param socket the connected socket
+     */
+    void ConnectionSucceeded(Ptr<Socket> socket);
+    /**
+     * \brief Connection Failed (called by Socket through a callback)
+     * \param socket the connected socket
+     */
+    void ConnectionFailed(Ptr<Socket> socket);
+    /**
+     * \brief Close Succeeded (called by Socket through a callback)
+     * \param socket the closed socket
+     */
+    void CloseSucceeded(Ptr<Socket> socket);
+    /**
+     * \brief Close Failed (called by Socket through a callback)
+     * \param socket the closed socket
+     */
+    void CloseFailed(Ptr<Socket> socket);
+    /**
+     * \brief Send more data as soon as some has been transmitted.
+     */
+    void DataSend(Ptr<Socket>, uint32_t); // for socket's SetSendCallback
+
+    /**
+     * Event handler for forcing scheduled TCP file transfer connection close
+     */
+    void HandleScheduledFileTransferEnd();
+};
+
+} // namespace ns3
+
+#endif /* FTP_APPLICATION_H */
diff -Naur ns-3.39/src/applications/model/game-client.cc docsis31_ns3_model/src/applications/model/game-client.cc
--- ns-3.39/src/applications/model/game-client.cc	1969-12-31 16:00:00.000000000 -0800
+++ docsis31_ns3_model/src/applications/model/game-client.cc	2023-08-31 20:38:06.989353798 -0700
@@ -0,0 +1,291 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2017-2020 Cable Television Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the authors may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "game-client.h"
+
+#include "ns3/address.h"
+#include "ns3/boolean.h"
+#include "ns3/double.h"
+#include "ns3/enum.h"
+#include "ns3/inet-socket-address.h"
+#include "ns3/inet6-socket-address.h"
+#include "ns3/ipv4-header.h"
+#include "ns3/log.h"
+#include "ns3/node.h"
+#include "ns3/nstime.h"
+#include "ns3/packet-socket-address.h"
+#include "ns3/packet.h"
+#include "ns3/pointer.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/simulator.h"
+#include "ns3/socket-factory.h"
+#include "ns3/socket.h"
+#include "ns3/string.h"
+#include "ns3/trace-source-accessor.h"
+#include "ns3/udp-socket-factory.h"
+#include "ns3/uinteger.h"
+
+namespace ns3
+{
+
+NS_LOG_COMPONENT_DEFINE("GameClient");
+
+NS_OBJECT_ENSURE_REGISTERED(GameClient);
+
+TypeId
+GameClient::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::GameClient")
+                            .SetParent<Application>()
+                            .SetGroupName("Applications")
+                            .AddConstructor<GameClient>()
+                            .AddAttribute("InterarrivalTime",
+                                          "Interarrival time",
+                                          TimeValue(MilliSeconds(33)),
+                                          MakeTimeAccessor(&GameClient::m_interarrivalTime),
+                                          MakeTimeChecker())
+                            .AddAttribute("InterarrivalDeviation",
+                                          "Standard deviation around mean IAT",
+                                          TimeValue(MilliSeconds(3)),
+                                          MakeTimeAccessor(&GameClient::SetInterarrivalDeviation,
+                                                           &GameClient::GetInterarrivalDeviation),
+                                          MakeTimeChecker())
+                            .AddAttribute("Size",
+                                          "The mean size of packets sent in on state",
+                                          UintegerValue(82),
+                                          MakeUintegerAccessor(&GameClient::m_size),
+                                          MakeUintegerChecker<uint32_t>(4))
+                            .AddAttribute("SizeDeviation",
+                                          "Standard deviation around mean size (bytes)",
+                                          UintegerValue(20),
+                                          MakeUintegerAccessor(&GameClient::SetSizeDeviation,
+                                                               &GameClient::GetSizeDeviation),
+                                          MakeUintegerChecker<uint32_t>())
+                            .AddAttribute("ServerAddress",
+                                          "The address of the destination",
+                                          AddressValue(),
+                                          MakeAddressAccessor(&GameClient::m_server),
+                                          MakeAddressChecker())
+                            .AddAttribute("Dscp",
+                                          "The DSCP value to use.",
+                                          EnumValue(Ipv4Header::DscpType::DSCP_EF),
+                                          MakeEnumAccessor(&GameClient::m_dscp),
+                                          MakeEnumChecker(Ipv4Header::DscpType::DSCP_EF,
+                                                          "DSCP_EF",
+                                                          Ipv4Header::DscpType::DscpDefault,
+                                                          "DscpDefault"))
+                            .AddTraceSource("Tx",
+                                            "A new packet is created and is sent",
+                                            MakeTraceSourceAccessor(&GameClient::m_txTrace),
+                                            "ns3::Packet::TracedCallback");
+    return tid;
+}
+
+GameClient::GameClient()
+    : m_socket(nullptr)
+{
+    NS_LOG_FUNCTION(this);
+    m_interarrivalRv = CreateObject<NormalRandomVariable>();
+    m_sizeRv = CreateObject<NormalRandomVariable>();
+}
+
+GameClient::~GameClient()
+{
+    NS_LOG_FUNCTION(this);
+}
+
+Ptr<Socket>
+GameClient::GetSocket() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_socket;
+}
+
+void
+GameClient::SetRemote(Address addr)
+{
+    NS_LOG_FUNCTION(this << addr);
+    m_server = addr;
+}
+
+int64_t
+GameClient::AssignStreams(int64_t stream)
+{
+    NS_LOG_FUNCTION(this << stream);
+    m_interarrivalRv->SetStream(stream);
+    m_sizeRv->SetStream(stream);
+    return 2;
+}
+
+void
+GameClient::DoDispose()
+{
+    NS_LOG_FUNCTION(this);
+
+    m_socket = nullptr;
+    // chain up
+    Application::DoDispose();
+}
+
+void
+GameClient::StartApplication()
+{
+    NS_LOG_FUNCTION(this);
+
+    // Create the socket if not already
+    if (!m_socket)
+    {
+        TypeId tid = TypeId::LookupByName("ns3::UdpSocketFactory");
+        m_socket = Socket::CreateSocket(GetNode(), tid);
+        if (Inet6SocketAddress::IsMatchingType(m_server))
+        {
+            if (m_socket->Bind6() == -1)
+            {
+                NS_FATAL_ERROR("Failed to bind socket");
+            }
+        }
+        else if (InetSocketAddress::IsMatchingType(m_server) ||
+                 PacketSocketAddress::IsMatchingType(m_server))
+        {
+            if (m_socket->Bind() == -1)
+            {
+                NS_FATAL_ERROR("Failed to bind socket");
+            }
+        }
+        m_socket->Connect(m_server);
+        m_socket->SetAllowBroadcast(true);
+        m_socket->ShutdownRecv();
+
+        m_socket->SetConnectCallback(MakeCallback(&GameClient::ConnectionSucceeded, this),
+                                     MakeCallback(&GameClient::ConnectionFailed, this));
+    }
+
+    // Insure no pending event
+    CancelEvents();
+    SendPacket(Seconds(0));
+}
+
+void
+GameClient::StopApplication()
+{
+    NS_LOG_FUNCTION(this);
+
+    CancelEvents();
+    if (m_socket)
+    {
+        m_socket->Close();
+    }
+    else
+    {
+        NS_LOG_WARN("GameClient found null socket to close in StopApplication");
+    }
+}
+
+void
+GameClient::CancelEvents()
+{
+    NS_LOG_FUNCTION(this);
+    Simulator::Cancel(m_sendEvent);
+}
+
+void
+GameClient::SendPacket(Time lastJitter)
+{
+    NS_LOG_FUNCTION(this);
+    int32_t size = m_size + static_cast<int32_t>(m_sizeRv->GetValue());
+    size = (size >= 4) ? size : 4;
+
+    Ptr<Packet> packet = Create<Packet>(static_cast<uint32_t>(size));
+    m_txTrace(packet);
+    m_socket->Send(packet);
+    if (InetSocketAddress::IsMatchingType(m_server))
+    {
+        NS_LOG_INFO("Sent " << packet->GetSize() << " bytes to "
+                            << InetSocketAddress::ConvertFrom(m_server).GetIpv4() << " port "
+                            << InetSocketAddress::ConvertFrom(m_server).GetPort());
+    }
+    else if (Inet6SocketAddress::IsMatchingType(m_server))
+    {
+        NS_LOG_INFO("Sent " << packet->GetSize() << " bytes to "
+                            << Inet6SocketAddress::ConvertFrom(m_server).GetIpv6() << " port "
+                            << Inet6SocketAddress::ConvertFrom(m_server).GetPort());
+    }
+    Time jitter = Seconds(m_interarrivalRv->GetValue());
+    m_sendEvent = Simulator::Schedule(m_interarrivalTime - lastJitter + jitter,
+                                      &GameClient::SendPacket,
+                                      this,
+                                      jitter);
+}
+
+void
+GameClient::ConnectionSucceeded(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+}
+
+void
+GameClient::ConnectionFailed(Ptr<Socket> socket)
+{
+    NS_LOG_FUNCTION(this << socket);
+}
+
+void
+GameClient::SetInterarrivalDeviation(Time interarrivalDeviation)
+{
+    m_interarrivalDeviation = interarrivalDeviation;
+    m_interarrivalRv->SetAttribute(
+        "Variance",
+        DoubleValue(interarrivalDeviation.GetSeconds() * interarrivalDeviation.GetSeconds()));
+}
+
+Time
+GameClient::GetInterarrivalDeviation() const
+{
+    return m_interarrivalDeviation;
+}
+
+void
+GameClient::SetSizeDeviation(uint32_t sizeDeviation)
+{
+    m_sizeDeviation = sizeDeviation;
+    m_sizeRv->SetAttribute("Variance", DoubleValue(sizeDeviation * sizeDeviation));
+}
+
+uint32_t
+GameClient::GetSizeDeviation() const
+{
+    return m_sizeDeviation;
+}
+
+} // Namespace ns3
diff -Naur ns-3.39/src/applications/model/game-client.h docsis31_ns3_model/src/applications/model/game-client.h
--- ns-3.39/src/applications/model/game-client.h	1969-12-31 16:00:00.000000000 -0800
+++ docsis31_ns3_model/src/applications/model/game-client.h	2023-08-31 20:38:02.081315973 -0700
@@ -0,0 +1,158 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2017-2020 Cable Television Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the authors may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GAME_CLIENT_H
+#define GAME_CLIENT_H
+
+#include "ns3/address.h"
+#include "ns3/application.h"
+#include "ns3/data-rate.h"
+#include "ns3/event-id.h"
+#include "ns3/ipv4-header.h"
+#include "ns3/ptr.h"
+#include "ns3/traced-callback.h"
+
+namespace ns3
+{
+
+class Address;
+class NormalRandomVariable;
+class Socket;
+
+/**
+ * \ingroup applications
+ *
+ * This traffic generator generates notional game packets, characterized
+ * by a fixed interarrival time varied by a jitter component; the jitter
+ * component is a zero-mean normal random variable.  The packet size
+ * is also drawn from a second normal random variable (again, based on
+ * a mean plus or minus a random variate drawn from a zero-mean normal
+ * random variable).  This approach is chosen to avoid variance on the
+ * game packet arrival time from growing over simulation time.
+ */
+class GameClient : public Application
+{
+  public:
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    GameClient();
+
+    ~GameClient() override;
+
+    /**
+     * \brief Return a pointer to associated socket.
+     * \return pointer to associated socket
+     */
+    Ptr<Socket> GetSocket() const;
+
+    /**
+     * \brief set the remote address
+     * \param addr remote address
+     */
+    void SetRemote(Address addr);
+
+    /**
+     * \brief Assign a fixed random variable stream number to the random variables
+     * used by this model.
+     *
+     * \param stream first stream index to use
+     * \return the number of stream indices assigned by this model
+     */
+    int64_t AssignStreams(int64_t stream);
+
+  protected:
+    void DoDispose() override;
+
+  private:
+    // inherited from Application base class.
+    void StartApplication() override; // Called at time specified by Start
+    void StopApplication() override;  // Called at time specified by Stop
+
+    // helpers
+    /**
+     * \brief Cancel all pending events.
+     */
+    void CancelEvents();
+
+    /**
+     * \brief Send a packet and schedule the next send
+     *
+     * Packets are sent every interarrival time +/- a small amount of jitter
+     * provided by a zero-mean normal random variable.
+     * The packet size is also varied according to a random variable.
+     *
+     * \param jitter the amount of jitter around the interarrival mean that
+     * was used to schedule this event
+     */
+    void SendPacket(Time jitter);
+
+    Ptr<Socket> m_socket;                       //!< Associated socket
+    Address m_server;                           //!< Peer address
+    Time m_interarrivalTime;                    //!< Mean interarrival time
+    Time m_interarrivalDeviation;               //!< Standard dev. around mean IAT
+    Ptr<NormalRandomVariable> m_interarrivalRv; //!< rng for interarrival time
+    uint32_t m_size;                            //!< Size of packets
+    uint32_t m_sizeDeviation;                   //!< Standard dev. around size
+    Ptr<NormalRandomVariable> m_sizeRv;         //!< rng for packet size
+    Ipv4Header::DscpType m_dscp;                //!< DSCP value to use
+    EventId m_sendEvent;                        //!< Event id of pending "send packet" event
+
+    /// Traced Callback: transmitted packets.
+    TracedCallback<Ptr<const Packet>> m_txTrace;
+
+  private:
+    /**
+     * \brief Handle a Connection Succeed event
+     * \param socket the connected socket
+     */
+    void ConnectionSucceeded(Ptr<Socket> socket);
+    /**
+     * \brief Handle a Connection Failed event
+     * \param socket the not connected socket
+     */
+    void ConnectionFailed(Ptr<Socket> socket);
+
+    void SetInterarrivalDeviation(Time interarrivalDeviation);
+    Time GetInterarrivalDeviation() const;
+    void SetSizeDeviation(uint32_t sizeDeviation);
+    uint32_t GetSizeDeviation() const;
+};
+
+} // namespace ns3
+
+#endif /* GAME_CLIENT */
diff -Naur ns-3.39/src/applications/model/onoff-application.cc docsis31_ns3_model/src/applications/model/onoff-application.cc
--- ns-3.39/src/applications/model/onoff-application.cc	2023-08-31 20:41:59.295179404 -0700
+++ docsis31_ns3_model/src/applications/model/onoff-application.cc	2023-08-31 20:38:41.025617084 -0700
@@ -108,6 +108,27 @@
                           BooleanValue(false),
                           MakeBooleanAccessor(&OnOffApplication::m_enableSeqTsSizeHeader),
                           MakeBooleanChecker())
+            .AddAttribute(
+                "RandomSize",
+                "An optional random variable that replaces the use of fixed PacketSize variable",
+                StringValue("ns3::ConstantRandomVariable[Constant=512.0]"),
+                MakePointerAccessor(&OnOffApplication::m_randomSize),
+                MakePointerChecker<RandomVariableStream>())
+            .AddAttribute("UseRandomSize",
+                          "Flag for whether packet distribution or fixed packet size is used",
+                          BooleanValue(false),
+                          MakeBooleanAccessor(&OnOffApplication::m_useRandomSize),
+                          MakeBooleanChecker())
+            .AddAttribute("RandomInterval",
+                          "An optional random variable that replaces the use of fixed DataRate",
+                          StringValue("ns3::ConstantRandomVariable[Constant=512.0]"),
+                          MakePointerAccessor(&OnOffApplication::m_randomInterval),
+                          MakePointerChecker<RandomVariableStream>())
+            .AddAttribute("UseRandomInterval",
+                          "Flag for whether interval distribution or fixed DataRate is used",
+                          BooleanValue(false),
+                          MakeBooleanAccessor(&OnOffApplication::m_useRandomInterval),
+                          MakeBooleanChecker())
             .AddTraceSource("Tx",
                             "A new packet is created and is sent",
                             MakeTraceSourceAccessor(&OnOffApplication::m_txTrace),
@@ -159,7 +180,9 @@
     NS_LOG_FUNCTION(this << stream);
     m_onTime->SetStream(stream);
     m_offTime->SetStream(stream + 1);
-    return 2;
+    m_randomInterval->SetStream(stream + 2);
+    m_randomSize->SetStream(stream + 3);
+    return 4;
 }
 
 void
@@ -306,8 +329,20 @@
                         "Calculation to compute next send time will overflow");
         uint32_t bits = m_pktSize * 8 - m_residualBits;
         NS_LOG_LOGIC("bits = " << bits);
-        Time nextTime(
-            Seconds(bits / static_cast<double>(m_cbrRate.GetBitRate()))); // Time till next packet
+        Time nextTime; // Time till next packet
+        if (m_useRandomInterval)
+        {
+            nextTime = Seconds(m_randomInterval->GetValue());
+            NS_ASSERT_MSG(nextTime.IsPositive(),
+                          "Packet interval is unexpectedly zero or negative. "
+                          "Please verify the configuration of "
+                          "`ns3::OnOffApplication::RandomInterval` "
+                          "random variable.");
+        }
+        else
+        {
+            nextTime = Seconds(bits / static_cast<double>(m_cbrRate.GetBitRate()));
+        }
         NS_LOG_LOGIC("nextTime = " << nextTime.As(Time::S));
         m_sendEvent = Simulator::Schedule(nextTime, &OnOffApplication::SendPacket, this);
     }
@@ -345,35 +380,53 @@
     NS_ASSERT(m_sendEvent.IsExpired());
 
     Ptr<Packet> packet;
+    uint32_t packetSize = 0;
     if (m_unsentPacket)
     {
         packet = m_unsentPacket;
-    }
-    else if (m_enableSeqTsSizeHeader)
-    {
-        Address from;
-        Address to;
-        m_socket->GetSockName(from);
-        m_socket->GetPeerName(to);
-        SeqTsSizeHeader header;
-        header.SetSeq(m_seq++);
-        header.SetSize(m_pktSize);
-        NS_ABORT_IF(m_pktSize < header.GetSerializedSize());
-        packet = Create<Packet>(m_pktSize - header.GetSerializedSize());
-        // Trace before adding header, for consistency with PacketSink
-        m_txTraceWithSeqTsSize(packet, from, to, header);
-        packet->AddHeader(header);
+        packetSize = packet->GetSize();
     }
     else
     {
-        packet = Create<Packet>(m_pktSize);
+        if (m_useRandomSize)
+        {
+            packetSize = m_randomSize->GetInteger();
+            NS_ASSERT_MSG(packetSize > 0,
+                          "Packet size was unexpectedly zero. "
+                          "Please verify the configuration of "
+                          "`ns3::OnOffApplication::RandomSize` "
+                          "random variable.");
+        }
+        else
+        {
+            packetSize = m_pktSize;
+        }
+        if (m_enableSeqTsSizeHeader)
+        {
+            Address from;
+            Address to;
+            m_socket->GetSockName(from);
+            m_socket->GetPeerName(to);
+            SeqTsSizeHeader header;
+            header.SetSeq(m_seq++);
+            packetSize = std::max<uint32_t>(packetSize, header.GetSerializedSize());
+            header.SetSize(packetSize);
+            packet = Create<Packet>(packetSize - header.GetSerializedSize());
+            // Trace before adding header, for consistency with PacketSink
+            m_txTraceWithSeqTsSize(packet, from, to, header);
+            packet->AddHeader(header);
+        }
+        else
+        {
+            packet = Create<Packet>(packetSize);
+        }
     }
 
     int actual = m_socket->Send(packet);
-    if ((unsigned)actual == m_pktSize)
+    if ((unsigned)actual == packetSize)
     {
         m_txTrace(packet);
-        m_totBytes += m_pktSize;
+        m_totBytes += packetSize;
         m_unsentPacket = nullptr;
         Address localAddress;
         m_socket->GetSockName(localAddress);
@@ -398,7 +451,7 @@
     }
     else
     {
-        NS_LOG_DEBUG("Unable to send packet; actual " << actual << " size " << m_pktSize
+        NS_LOG_DEBUG("Unable to send packet; actual " << actual << " size " << packetSize
                                                       << "; caching for later attempt");
         m_unsentPacket = packet;
     }
diff -Naur ns-3.39/src/applications/model/onoff-application.h docsis31_ns3_model/src/applications/model/onoff-application.h
--- ns-3.39/src/applications/model/onoff-application.h	2023-08-31 20:41:59.295179404 -0700
+++ docsis31_ns3_model/src/applications/model/onoff-application.h	2023-08-31 18:10:55.092384164 -0700
@@ -158,25 +158,29 @@
      */
     void SendPacket();
 
-    Ptr<Socket> m_socket;                //!< Associated socket
-    Address m_peer;                      //!< Peer address
-    Address m_local;                     //!< Local address to bind to
-    bool m_connected;                    //!< True if connected
-    Ptr<RandomVariableStream> m_onTime;  //!< rng for On Time
-    Ptr<RandomVariableStream> m_offTime; //!< rng for Off Time
-    DataRate m_cbrRate;                  //!< Rate that data is generated
-    DataRate m_cbrRateFailSafe;          //!< Rate that data is generated (check copy)
-    uint32_t m_pktSize;                  //!< Size of packets
-    uint32_t m_residualBits;             //!< Number of generated, but not sent, bits
-    Time m_lastStartTime;                //!< Time last packet sent
-    uint64_t m_maxBytes;                 //!< Limit total number of bytes sent
-    uint64_t m_totBytes;                 //!< Total bytes sent so far
-    EventId m_startStopEvent;            //!< Event id for next start or stop event
-    EventId m_sendEvent;                 //!< Event id of pending "send packet" event
-    TypeId m_tid;                        //!< Type of the socket used
-    uint32_t m_seq{0};                   //!< Sequence
-    Ptr<Packet> m_unsentPacket;          //!< Unsent packet cached for future attempt
-    bool m_enableSeqTsSizeHeader{false}; //!< Enable or disable the use of SeqTsSizeHeader
+    Ptr<Socket> m_socket;                       //!< Associated socket
+    Address m_peer;                             //!< Peer address
+    Address m_local;                            //!< Local address to bind to
+    bool m_connected;                           //!< True if connected
+    Ptr<RandomVariableStream> m_onTime;         //!< rng for On Time
+    Ptr<RandomVariableStream> m_offTime;        //!< rng for Off Time
+    Ptr<RandomVariableStream> m_randomSize;     //!< rng for packet size distribution
+    bool m_useRandomSize;                       //!< boolean to use packet distribution
+    Ptr<RandomVariableStream> m_randomInterval; //!< rng for interarrival time
+    bool m_useRandomInterval;                   //!< boolean to use interval distribution
+    DataRate m_cbrRate;                         //!< Rate that data is generated
+    DataRate m_cbrRateFailSafe;                 //!< Rate that data is generated (check copy)
+    uint32_t m_pktSize;                         //!< Size of packets
+    uint32_t m_residualBits;                    //!< Number of generated, but not sent, bits
+    Time m_lastStartTime;                       //!< Time last packet sent
+    uint64_t m_maxBytes;                        //!< Limit total number of bytes sent
+    uint64_t m_totBytes;                        //!< Total bytes sent so far
+    EventId m_startStopEvent;                   //!< Event id for next start or stop event
+    EventId m_sendEvent;                        //!< Event id of pending "send packet" event
+    TypeId m_tid;                               //!< Type of the socket used
+    uint32_t m_seq{0};                          //!< Sequence
+    Ptr<Packet> m_unsentPacket;                 //!< Unsent packet cached for future attempt
+    bool m_enableSeqTsSizeHeader{false};        //!< Enable or disable the use of SeqTsSizeHeader
 
     /// Traced Callback: transmitted packets.
     TracedCallback<Ptr<const Packet>> m_txTrace;
diff -Naur ns-3.39/src/applications/model/udp-client.cc docsis31_ns3_model/src/applications/model/udp-client.cc
--- ns-3.39/src/applications/model/udp-client.cc	2023-08-31 20:41:59.299179436 -0700
+++ docsis31_ns3_model/src/applications/model/udp-client.cc	2023-08-31 20:38:53.865716831 -0700
@@ -21,6 +21,7 @@
 
 #include "seq-ts-header.h"
 
+#include "ns3/boolean.h"
 #include "ns3/inet-socket-address.h"
 #include "ns3/inet6-socket-address.h"
 #include "ns3/ipv4-address.h"
@@ -50,6 +51,11 @@
             .SetParent<Application>()
             .SetGroupName("Applications")
             .AddConstructor<UdpClient>()
+            .AddAttribute("OnDemand",
+                          "If true, will only send packets on demand and not at regular interval",
+                          BooleanValue(false),
+                          MakeBooleanAccessor(&UdpClient::m_onDemand),
+                          MakeBooleanChecker())
             .AddAttribute(
                 "MaxPackets",
                 "The maximum number of packets the application will send (zero means infinite)",
@@ -71,6 +77,12 @@
                           UintegerValue(100),
                           MakeUintegerAccessor(&UdpClient::m_peerPort),
                           MakeUintegerChecker<uint16_t>())
+            .AddAttribute("LocalPort",
+                          "The local port of the outbound packets (IPv4 "
+                          "only); the value 0 will cause an ephemeral port to be used",
+                          UintegerValue(0),
+                          MakeUintegerAccessor(&UdpClient::m_localPort),
+                          MakeUintegerChecker<uint16_t>())
             .AddAttribute("PacketSize",
                           "Size of packets generated. The minimum packet size is 12 bytes which is "
                           "the size of the header carrying the sequence number and the time stamp.",
@@ -100,6 +112,11 @@
 UdpClient::~UdpClient()
 {
     NS_LOG_FUNCTION(this);
+    Simulator::Cancel(m_sendEvent);
+    for (auto it = m_sendEvents.begin(); it != m_sendEvents.end(); it++)
+    {
+        Simulator::Cancel(it->second);
+    }
 }
 
 void
@@ -135,7 +152,15 @@
         m_socket = Socket::CreateSocket(GetNode(), tid);
         if (Ipv4Address::IsMatchingType(m_peerAddress))
         {
-            if (m_socket->Bind() == -1)
+            if (m_localPort > 0)
+            {
+                InetSocketAddress socketAddr(Ipv4Address::GetAny(), m_localPort);
+                if (m_socket->Bind(socketAddr) == -1)
+                {
+                    NS_FATAL_ERROR("Failed to bind socket");
+                }
+            }
+            else if (m_socket->Bind() == -1)
             {
                 NS_FATAL_ERROR("Failed to bind socket");
             }
@@ -144,7 +169,15 @@
         }
         else if (Ipv6Address::IsMatchingType(m_peerAddress))
         {
-            if (m_socket->Bind6() == -1)
+            if (m_localPort > 0)
+            {
+                Inet6SocketAddress socketAddr(Ipv6Address::GetAny(), m_localPort);
+                if (m_socket->Bind(socketAddr) == -1)
+                {
+                    NS_FATAL_ERROR("Failed to bind socket");
+                }
+            }
+            else if (m_socket->Bind() == -1)
             {
                 NS_FATAL_ERROR("Failed to bind socket");
             }
@@ -153,7 +186,15 @@
         }
         else if (InetSocketAddress::IsMatchingType(m_peerAddress))
         {
-            if (m_socket->Bind() == -1)
+            if (m_localPort > 0)
+            {
+                InetSocketAddress socketAddr(Ipv4Address::GetAny(), m_localPort);
+                if (m_socket->Bind(socketAddr) == -1)
+                {
+                    NS_FATAL_ERROR("Failed to bind socket");
+                }
+            }
+            else if (m_socket->Bind() == -1)
             {
                 NS_FATAL_ERROR("Failed to bind socket");
             }
@@ -161,7 +202,15 @@
         }
         else if (Inet6SocketAddress::IsMatchingType(m_peerAddress))
         {
-            if (m_socket->Bind6() == -1)
+            if (m_localPort > 0)
+            {
+                Inet6SocketAddress socketAddr(Ipv6Address::GetAny(), m_localPort);
+                if (m_socket->Bind(socketAddr) == -1)
+                {
+                    NS_FATAL_ERROR("Failed to bind socket");
+                }
+            }
+            else if (m_socket->Bind() == -1)
             {
                 NS_FATAL_ERROR("Failed to bind socket");
             }
@@ -196,7 +245,10 @@
 
     m_socket->SetRecvCallback(MakeNullCallback<void, Ptr<Socket>>());
     m_socket->SetAllowBroadcast(true);
-    m_sendEvent = Simulator::Schedule(Seconds(0.0), &UdpClient::Send, this);
+    if (!m_onDemand)
+    {
+        m_sendEvent = Simulator::Schedule(Seconds(0.0), &UdpClient::Send, this);
+    }
 }
 
 void
@@ -204,6 +256,65 @@
 {
     NS_LOG_FUNCTION(this);
     Simulator::Cancel(m_sendEvent);
+    for (auto it = m_sendEvents.begin(); it != m_sendEvents.end(); it++)
+    {
+        Simulator::Cancel(it->second);
+    }
+    if (m_socket)
+    {
+        m_socket->Close();
+    }
+}
+
+void
+UdpClient::SendPacket(uint32_t size)
+{
+    NS_LOG_FUNCTION(this << size);
+    SeqTsHeader seqTs;
+    seqTs.SetSeq(m_sent);
+    Ptr<Packet> p;
+    if (size < 12)
+    {
+        NS_LOG_DEBUG("Limiting size to 12");
+        p = Create<Packet>();
+        size = 12;
+    }
+    else
+    {
+        p = Create<Packet>(size - (8 + 4)); // 8+4 : the size of the seqTs header
+    }
+    p->AddHeader(seqTs);
+    std::stringstream peerAddressStringStream;
+    if (Ipv4Address::IsMatchingType(m_peerAddress))
+    {
+        peerAddressStringStream << Ipv4Address::ConvertFrom(m_peerAddress);
+    }
+    else if (Ipv6Address::IsMatchingType(m_peerAddress))
+    {
+        peerAddressStringStream << Ipv6Address::ConvertFrom(m_peerAddress);
+    }
+    if ((m_socket->Send(p)) >= 0)
+    {
+        ++m_sent;
+        m_txTrace(p);
+        NS_LOG_INFO("TraceDelay TX " << size << " bytes to " << peerAddressStringStream.str()
+                                     << " Uid: " << p->GetUid()
+                                     << " Time: " << (Simulator::Now()).GetSeconds());
+    }
+    else
+    {
+        NS_LOG_INFO("Error while sending " << size << " bytes to "
+                                           << peerAddressStringStream.str());
+    }
+}
+
+void
+UdpClient::SendPacketAt(Time t, uint32_t size)
+{
+    NS_LOG_FUNCTION(this << t << size);
+    EventId e = Simulator::Schedule(t, &UdpClient::SendPacket, this, size);
+    // For future work:  store a per-object UID to be used to remove from map
+    m_sendEvents.insert(std::map<uint32_t, EventId>::value_type(e.GetUid(), e));
 }
 
 void
@@ -230,6 +341,7 @@
     if ((m_socket->Send(p)) >= 0)
     {
         ++m_sent;
+        m_txTrace(p);
         m_totalTx += p->GetSize();
 #ifdef NS3_LOG_ENABLE
         NS_LOG_INFO("TraceDelay TX " << m_size << " bytes to " << m_peerAddressString << " Uid: "
diff -Naur ns-3.39/src/applications/model/udp-client.h docsis31_ns3_model/src/applications/model/udp-client.h
--- ns-3.39/src/applications/model/udp-client.h	2023-08-31 20:41:59.299179436 -0700
+++ docsis31_ns3_model/src/applications/model/udp-client.h	2023-08-31 20:02:22.516944624 -0700
@@ -28,6 +28,8 @@
 #include "ns3/ptr.h"
 #include <ns3/traced-callback.h>
 
+#include <map>
+
 namespace ns3
 {
 
@@ -71,6 +73,19 @@
      */
     uint64_t GetTotalTx() const;
 
+    /**
+     * \param size Payload size in bytes
+     * \brief Immediately send one packet
+     */
+    void SendPacket(uint32_t size);
+
+    /**
+     * \param t Time from now to schedule a send
+     * \param size Payload size in bytes
+     * \brief Send one packet at t time in the future
+     */
+    void SendPacketAt(Time t, uint32_t size);
+
   protected:
     void DoDispose() override;
 
@@ -98,11 +113,14 @@
     Ptr<Socket> m_socket;  //!< Socket
     Address m_peerAddress; //!< Remote peer address
     uint16_t m_peerPort;   //!< Remote peer port
+    uint16_t m_localPort;  //!< Local port
     EventId m_sendEvent;   //!< Event to send the next packet
 
 #ifdef NS3_LOG_ENABLE
-    std::string m_peerAddressString; //!< Remote peer address string
-#endif                               // NS3_LOG_ENABLE
+    std::string m_peerAddressString;          //!< Remote peer address string
+#endif                                        // NS3_LOG_ENABLE
+    bool m_onDemand;                          //!< Mode flag for on-demand operation
+    std::map<uint32_t, EventId> m_sendEvents; //!< Container for on-demand events
 };
 
 } // namespace ns3
diff -Naur ns-3.39/src/applications/model/udp-server.cc docsis31_ns3_model/src/applications/model/udp-server.cc
--- ns-3.39/src/applications/model/udp-server.cc	2023-08-31 20:41:59.303179468 -0700
+++ docsis31_ns3_model/src/applications/model/udp-server.cc	2023-08-31 18:10:55.096384209 -0700
@@ -32,6 +32,7 @@
 #include "ns3/simulator.h"
 #include "ns3/socket-factory.h"
 #include "ns3/socket.h"
+#include "ns3/traced-callback.h"
 #include "ns3/uinteger.h"
 
 namespace ns3
@@ -61,6 +62,10 @@
                           MakeUintegerAccessor(&UdpServer::GetPacketWindowSize,
                                                &UdpServer::SetPacketWindowSize),
                           MakeUintegerChecker<uint16_t>(8, 256))
+            .AddTraceSource("PacketLatency",
+                            "Latency sample for received packet",
+                            MakeTraceSourceAccessor(&UdpServer::m_packetLatency),
+                            "ns3::TracedValueCallback::Time")
             .AddTraceSource("Rx",
                             "A packet has been received",
                             MakeTraceSourceAccessor(&UdpServer::m_rxTrace),
@@ -156,9 +161,14 @@
 {
     NS_LOG_FUNCTION(this);
 
+    m_socket6->SetRecvCallback(MakeNullCallback<void, Ptr<Socket>>());
     if (m_socket)
     {
-        m_socket->SetRecvCallback(MakeNullCallback<void, Ptr<Socket>>());
+        m_socket->Close();
+    }
+    if (m_socket6)
+    {
+        m_socket6->Close();
     }
 }
 
@@ -180,6 +190,7 @@
             SeqTsHeader seqTs;
             packet->RemoveHeader(seqTs);
             uint32_t currentSequenceNumber = seqTs.GetSeq();
+            m_packetLatency(Simulator::Now(), Simulator::Now() - seqTs.GetTs());
             if (InetSocketAddress::IsMatchingType(from))
             {
                 NS_LOG_INFO("TraceDelay: RX " << receivedSize << " bytes from "
diff -Naur ns-3.39/src/applications/model/udp-server.h docsis31_ns3_model/src/applications/model/udp-server.h
--- ns-3.39/src/applications/model/udp-server.h	2023-08-31 20:41:59.303179468 -0700
+++ docsis31_ns3_model/src/applications/model/udp-server.h	2023-08-31 18:10:55.096384209 -0700
@@ -103,6 +103,7 @@
     Ptr<Socket> m_socket6;           //!< IPv6 Socket
     uint64_t m_received;             //!< Number of received packets
     PacketLossCounter m_lossCounter; //!< Lost packet counter
+    TracedCallback<Time, Time> m_packetLatency;
 
     /// Callbacks for tracing the packet Rx events
     TracedCallback<Ptr<const Packet>> m_rxTrace;
